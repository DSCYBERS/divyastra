import requests
import json
import time
import hashlib
from typing import Dict, List, Optional, Set
from datetime import datetime, timedelta
from concurrent.futures import ThreadPoolExecutor, as_completed
import re

class VulnerabilityFeed:
    """Base class for vulnerability feeds"""
    def __init__(self, name: str, url: str, update_interval: int = 3600):
        self.name = name
        self.url = url
        self.update_interval = update_interval
        self.last_updated = 0
        self.vulnerabilities = []

    def needs_update(self) -> bool:
        return (time.time() - self.last_updated) > self.update_interval

    def update(self) -> bool:
        """Update vulnerability feed - to be implemented by subclasses"""
        raise NotImplementedError

class CVEFeed(VulnerabilityFeed):
    """CVE/NVD vulnerability feed"""
    def __init__(self):
        super().__init__(
            name="CVE/NVD",
            url="https://services.nvd.nist.gov/rest/json/cves/2.0",
            update_interval=3600  # Update every hour
        )

    def update(self) -> bool:
        """Update CVE feed from NVD"""
        try:
            print(f"  📡 Updating {self.name} feed...")
            
            # Get recent CVEs (last 7 days)
            end_date = datetime.now()
            start_date = end_date - timedelta(days=7)
            
            params = {
                'pubStartDate': start_date.strftime('%Y-%m-%dT%H:%M:%S.000'),
                'pubEndDate': end_date.strftime('%Y-%m-%dT%H:%M:%S.000'),
                'resultsPerPage': 2000
            }
            
            response = requests.get(self.url, params=params, timeout=30)
            
            if response.status_code == 200:
                data = response.json()
                self.vulnerabilities = []
                
                for cve in data.get('vulnerabilities', []):
                    cve_data = cve.get('cve', {})
                    vuln = {
                        'id': cve_data.get('id', ''),
                        'description': self._extract_description(cve_data),
                        'severity': self._extract_severity(cve_data),
                        'cvss_score': self._extract_cvss_score(cve_data),
                        'published': cve_data.get('published', ''),
                        'modified': cve_data.get('lastModified', ''),
                        'references': self._extract_references(cve_data),
                        'affected_products': self._extract_affected_products(cve_data),
                        'source': 'CVE/NVD'
                    }
                    self.vulnerabilities.append(vuln)
                
                self.last_updated = time.time()
                print(f"    ✅ Updated {len(self.vulnerabilities)} CVE entries")
                return True
            else:
                print(f"    ❌ Failed to update CVE feed: {response.status_code}")
                return False
                
        except Exception as e:
            print(f"    ❌ CVE feed update failed: {str(e)}")
            return False

    def _extract_description(self, cve_data: Dict) -> str:
        descriptions = cve_data.get('descriptions', [])
        for desc in descriptions:
            if desc.get('lang') == 'en':
                return desc.get('value', '')
        return ''

    def _extract_severity(self, cve_data: Dict) -> str:
        metrics = cve_data.get('metrics', {})
        if 'cvssMetricV31' in metrics:
            return metrics['cvssMetricV31'][0].get('cvssData', {}).get('baseSeverity', 'UNKNOWN')
        elif 'cvssMetricV30' in metrics:
            return metrics['cvssMetricV30'][0].get('cvssData', {}).get('baseSeverity', 'UNKNOWN')
        return 'UNKNOWN'

    def _extract_cvss_score(self, cve_data: Dict) -> float:
        metrics = cve_data.get('metrics', {})
        if 'cvssMetricV31' in metrics:
            return metrics['cvssMetricV31'][0].get('cvssData', {}).get('baseScore', 0.0)
        elif 'cvssMetricV30' in metrics:
            return metrics['cvssMetricV30'][0].get('cvssData', {}).get('baseScore', 0.0)
        return 0.0

    def _extract_references(self, cve_data: Dict) -> List[str]:
        references = cve_data.get('references', [])
        return [ref.get('url', '') for ref in references]

    def _extract_affected_products(self, cve_data: Dict) -> List[str]:
        configurations = cve_data.get('configurations', [])
        products = set()
        
        for config in configurations:
            for node in config.get('nodes', []):
                for cpe_match in node.get('cpeMatch', []):
                    cpe = cpe_match.get('criteria', '')
                    if cpe:
                        # Extract product name from CPE
                        parts = cpe.split(':')
                        if len(parts) >= 5:
                            vendor = parts[3]
                            product = parts[4]
                            products.add(f"{vendor}:{product}")
        
        return list(products)

class ExploitDBFeed(VulnerabilityFeed):
    """ExploitDB feed for known exploits"""
    def __init__(self):
        super().__init__(
            name="ExploitDB",
            url="https://www.exploit-db.com/",
            update_interval=7200  # Update every 2 hours
        )

    def update(self) -> bool:
        """Update ExploitDB feed"""
        try:
            print(f"  🔥 Updating {self.name} feed...")
            # In production, this would parse ExploitDB CSV or use their API
            # For now, return a placeholder
            self.vulnerabilities = []
            self.last_updated = time.time()
            print(f"    ✅ Updated ExploitDB feed")
            return True
        except Exception as e:
            print(f"    ❌ ExploitDB feed update failed: {str(e)}")
            return False

class VulnerabilityScanner:
    def __init__(self, config: Optional[Dict] = None):
        self.config = config or {}
        self.feeds = {
            'cve': CVEFeed(),
            'exploitdb': ExploitDBFeed()
        }
        self.scan_results = []

    def update_all_feeds(self) -> Dict[str, bool]:
        """Update all vulnerability feeds"""
        print("🔄 Updating vulnerability feeds...")
        results = {}
        
        with ThreadPoolExecutor(max_workers=3) as executor:
            future_to_feed = {
                executor.submit(feed.update): name
                for name, feed in self.feeds.items()
                if feed.needs_update()
            }
            
            for future in as_completed(future_to_feed):
                feed_name = future_to_feed[future]
                try:
                    results[feed_name] = future.result()
                except Exception as e:
                    print(f"    ❌ {feed_name} update failed: {str(e)}")
                    results[feed_name] = False
        
        return results

    def scan_target(self, target_info: Dict) -> Dict:
        """Scan target for vulnerabilities"""
        print(f"🔍 Scanning {target_info.get('target', 'unknown')} for vulnerabilities...")
        
        # Update feeds if needed
        self.update_all_feeds()
        
        scan_result = {
            'target': target_info.get('target', ''),
            'timestamp': int(time.time()),
            'vulnerabilities': [],
            'statistics': {
                'total_checked': 0,
                'vulnerabilities_found': 0,
                'critical': 0,
                'high': 0,
                'medium': 0,
                'low': 0
            }
        }
        
        # Analyze target technologies against vulnerability databases
        technologies = target_info.get('technologies', [])
        open_ports = target_info.get('open_ports', [])
        
        scan_result['vulnerabilities'] = self._match_vulnerabilities(technologies, open_ports)
        scan_result['statistics'] = self._calculate_statistics(scan_result['vulnerabilities'])
        
        print(f"  ✅ Found {scan_result['statistics']['vulnerabilities_found']} vulnerabilities")
        return scan_result

    def _match_vulnerabilities(self, technologies: List[Dict], open_ports: List[Dict]) -> List[Dict]:
        """Match discovered technologies and services to known vulnerabilities"""
        vulnerabilities = []
        
        # Create search terms from technologies and services
        search_terms = set()
        
        # Add technology names
        for tech in technologies:
            name = tech.get('name', '').lower()
            if name:
                search_terms.add(name)
                # Extract product name (e.g., "Apache/2.4.41" -> "apache")
                product = name.split('/')[0].split(' ')[0]
                search_terms.add(product)
        
        # Add service names
        for port in open_ports:
            service = port.get('service', '').lower()
            if service:
                search_terms.add(service)
        
        # Search vulnerabilities in all feeds
        for feed_name, feed in self.feeds.items():
            for vuln in feed.vulnerabilities:
                if self._is_vulnerability_relevant(vuln, search_terms):
                    vulnerabilities.append({
                        'id': vuln['id'],
                        'title': vuln.get('description', '')[:200],
                        'description': vuln.get('description', ''),
                        'severity': vuln.get('severity', 'UNKNOWN'),
                        'cvss_score': vuln.get('cvss_score', 0.0),
                        'published': vuln.get('published', ''),
                        'references': vuln.get('references', []),
                        'affected_products': vuln.get('affected_products', []),
                        'source': vuln.get('source', feed_name),
                        'match_confidence': self._calculate_match_confidence(vuln, search_terms)
                    })
        
        # Sort by CVSS score (highest first)
        vulnerabilities.sort(key=lambda x: x['cvss_score'], reverse=True)
        
        return vulnerabilities[:100]  # Limit to top 100 vulnerabilities

    def _is_vulnerability_relevant(self, vulnerability: Dict, search_terms: Set[str]) -> bool:
        """Check if vulnerability is relevant to the target"""
        description = vulnerability.get('description', '').lower()
        affected_products = vulnerability.get('affected_products', [])
        
        # Check description for search terms
        for term in search_terms:
            if term in description:
                return True
        
        # Check affected products
        for product in affected_products:
            product_lower = product.lower()
            for term in search_terms:
                if term in product_lower:
                    return True
        
        return False

    def _calculate_match_confidence(self, vulnerability: Dict, search_terms: Set[str]) -> float:
        """Calculate confidence score for vulnerability match"""
        score = 0.0
        description = vulnerability.get('description', '').lower()
        affected_products = vulnerability.get('affected_products', [])
        
        # Check exact matches in description
        for term in search_terms:
            if term in description:
                score += 0.3
        
        # Check exact matches in affected products
        for product in affected_products:
            product_lower = product.lower()
            for term in search_terms:
                if term in product_lower:
                    score += 0.5
        
        return min(score, 1.0)  # Cap at 1.0

    def _calculate_statistics(self, vulnerabilities: List[Dict]) -> Dict:
        """Calculate vulnerability statistics"""
        stats = {
            'total_checked': len(vulnerabilities),
            'vulnerabilities_found': len(vulnerabilities),
            'critical': 0,
            'high': 0,
            'medium': 0,
            'low': 0,
            'unknown': 0
        }
        
        for vuln in vulnerabilities:
            severity = vuln.get('severity', 'UNKNOWN').upper()
            if severity == 'CRITICAL':
                stats['critical'] += 1
            elif severity == 'HIGH':
                stats['high'] += 1
            elif severity == 'MEDIUM':
                stats['medium'] += 1
            elif severity == 'LOW':
                stats['low'] += 1
            else:
                stats['unknown'] += 1
        
        return stats

    def generate_vulnerability_report(self, scan_results: Dict) -> str:
        """Generate detailed vulnerability report"""
        vulnerabilities = scan_results.get('vulnerabilities', [])
        stats = scan_results.get('statistics', {})
        
        report = f"""
DIVYASTRA Vulnerability Assessment Report
Target: {scan_results.get('target', 'Unknown')}
Scan Date: {datetime.fromtimestamp(scan_results.get('timestamp', 0)).strftime('%Y-%m-%d %H:%M:%S')}

EXECUTIVE SUMMARY:
• Total Vulnerabilities Found: {stats.get('vulnerabilities_found', 0)}
• Critical: {stats.get('critical', 0)}
• High: {stats.get('high', 0)}
• Medium: {stats.get('medium', 0)}
• Low: {stats.get('low', 0)}

TOP VULNERABILITIES:
"""
        
        # Add top 10 vulnerabilities
        for i, vuln in enumerate(vulnerabilities[:10], 1):
            report += f"""
{i}. {vuln.get('id', 'N/A')} - {vuln.get('severity', 'UNKNOWN')} (CVSS: {vuln.get('cvss_score', 0.0)})
   {vuln.get('title', 'No title available')}
   Match Confidence: {vuln.get('match_confidence', 0.0):.1%}
   Published: {vuln.get('published', 'Unknown')}
   Source: {vuln.get('source', 'Unknown')}
"""
        
        return report

    def get_feed_status(self) -> Dict:
        """Get status of all vulnerability feeds"""
        status = {}
        for name, feed in self.feeds.items():
            status[name] = {
                'name': feed.name,
                'last_updated': datetime.fromtimestamp(feed.last_updated).strftime('%Y-%m-%d %H:%M:%S') if feed.last_updated else 'Never',
                'vulnerabilities_count': len(feed.vulnerabilities),
                'needs_update': feed.needs_update(),
                'update_interval': feed.update_interval
            }
        return status